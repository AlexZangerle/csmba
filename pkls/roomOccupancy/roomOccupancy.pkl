import "https://raw.githubusercontent.com/CollaborativeStateMachines/Cirrina/refs/heads/develop/src/main/resources/pkl/csm/Csml.pkl"
import "https://raw.githubusercontent.com/AlexZangerle/csmba/main/pkls/events.pkl" as Events
import "https://raw.githubusercontent.com/AlexZangerle/csmba/main/pkls/serviceTypes.pkl" as ServiceTypes
import "https://raw.githubusercontent.com/AlexZangerle/csmba/main/pkls/variables.pkl" as Vars
import "https://raw.githubusercontent.com/AlexZangerle/csmba/main/pkls/roomOccupancy/actions.pkl" as Actions
import "https://raw.githubusercontent.com/AlexZangerle/csmba/main/pkls/roomOccupancy/context.pkl" as Context

// This module contains the definition for the room occupancy SM

// The room occupancy SM contains four states: vacant, occupied transient + and initialization state
// It also contains a nested state machine to monitor the detection process time
class roomOccupancySM extends Csml.StateMachineDescription {
  name = "roomOccupancy"
  localContext = Context.occupancyLocalContext
  stateMachines {
    new occupancyMonitor {}
    new occupancyChildTest {}
  }
  states {
    rInit
    rVacant
    rOccupied
    rTransient
  }
}

// The occupancyMonitor sm monitors the room occupancy SM.
// It starts a timer when the detection process begins.
// Should the detection process not finish before the timer runs out, maintenance is required.
class occupancyMonitor extends Csml.StateMachineDescription {
  name = "OccupancyMonitoring"
  states {
    omInit
    omIdle
    omMonitoring
    omMaintenance
  }
}

class occupancyChildTest extends Csml.StateMachineDescription {
  name = "testChild"
  states {
    tcInit
    tcRun1
    tcRun2
    tcRun3
    tcRun4
    tcRun5
    tcRun6
    tcRun7
    tcRun8
    tcRun9
    tcRun10
    tcRun11
    tcRun12
    tcRun13
    tcRun14
    tcRun15
    tcRun16
    tcFinal
    tcFinal1
    tcFinal2
    tcFinal3
    tcFinal4
    tcFinal5
    tcFinal6
    tcFinal7
  }
}

// Initially the SM will always transition to vacant
local const rInit: Csml.StateDescription = new {
  name = "init"
  initial = true
  always {
    new {
      target = rVacant.name
    }
  }
}

// The detection process is initiated every 30 seconds
local const rVacant: Csml.StateDescription = new {
  name = "vacant"
  entry {
    new Csml.AssignActionDescription{
      variable {
        name = Vars.vCurrentOccupancy
        value = "'vacant'"
      }
    }
  }
  after {
    new Csml.TimeoutActionDescription {
      name = "detectOccupancy"
      delay = "30000"
      action = Actions.aRaiseStartDetectingOccupancy
    }
  }
  on {
    new {
      event = Events.eStartDetectingOccupancy
      actions {
        new Csml.InvokeActionDescription {
          serviceType = ServiceTypes.stDetectOccupancy
          output {
            new {
              reference = Vars.vOccupancyDetected
            }
          }
          done {
            new {
              name = Events.eDetectionComplete
              channel = "internal"
            }
          }
        }
      }
    }
    // Transition to occupied once occupancy is detected
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = Vars.vOccupancyDetected
        }
      }
      actions {
        Actions.aRaiseOccupancyDetected
      }
      target = rOccupied.name
    }
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = "!\(Vars.vOccupancyDetected)"
        }
      }
      actions {
        Actions.aRaiseOccupancyVacant
      }
    }
  }
}

// The detection process is initiated every 30 seconds
local const rOccupied: Csml.StateDescription = new {
  name = "occupied"
  entry {
    new Csml.AssignActionDescription{
      variable {
        name = Vars.vCurrentOccupancy
        value = "'occupied'"
      }
    }
  }
  after {
    new Csml.TimeoutActionDescription {
      name = "detectOccupancy"
      delay = "30000"
      action = Actions.aRaiseStartDetectingOccupancy
    }
  }
  on {
    new {
      event = Events.eStartDetectingOccupancy
      actions {
        new Csml.InvokeActionDescription {
          serviceType = ServiceTypes.stDetectOccupancy
          output {
            new {
              reference = Vars.vOccupancyDetected
            }
          }
          done {
            new {
              name = Events.eDetectionComplete
              channel = "internal"
            }
          }
        }
      }
    }
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = Vars.vOccupancyDetected
        }
      }
      actions {
        Actions.aRaiseOccupancyDetected
      }
    }
    // Transition to transient once no occupancy is detected
    // This acts as a vacancy grace period
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = "!\(Vars.vOccupancyDetected)"
        }
      }
      actions {
        Actions.aRaiseOccupancyTransient
      }
      target = rTransient.name
    }
    // Energy saving prevents the lights from fully turning on (except manually)
    // Transition to transient to dim lights
    new {
      event = Events.eActivateEnergySaving
      target = rTransient.name
      actions{
        new Csml.AssignActionDescription {
          variable {
            name = Vars.vEnergySaving
            value = "true"
          }
        }
        Actions.aRaiseOccupancyTransient
      }
    }
  }
}

// The detection process is initiated every 30 seconds
local const rTransient: Csml.StateDescription = new {
  name = "transient"
  entry {
    new Csml.AssignActionDescription{
      variable {
        name = Vars.vCurrentOccupancy
        value = "'transient'"
      }
    }
  }
  after {
    new Csml.TimeoutActionDescription {
      name = "detectOccupancy"
      delay = "30000"
      action = Actions.aRaiseStartDetectingOccupancy
    }
  }
  on {
    new {
      event = Events.eStartDetectingOccupancy
      actions {
        new Csml.InvokeActionDescription {
          serviceType = ServiceTypes.stDetectOccupancy
          output {
            new {
              reference = Vars.vOccupancyDetected
            }
          }
          done {
            new {
              name = Events.eDetectionComplete
              channel = "internal"
            }
          }
        }
      }
    }
    // During grace period - transition to vacant if no occupancy is detected again
    // transition to occupied if occupancy is detected
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = Vars.vOccupancyDetected
        }
      }
      actions {
        Actions.aRaiseOccupancyDetected
      }
      target = rOccupied.name
    }
    new {
      event = Events.eDetectionComplete
      guards {
        new Csml.GuardDescription {
          expression = "!\(Vars.vOccupancyDetected)"
        }
      }
      actions {
        Actions.aRaiseOccupancyVacant
      }
      target = rVacant.name
    }
  }
}

local const omInit: Csml.StateDescription = new {
  name = "init"
  initial = true
  always {
    new {
      target = omIdle.name
    }
  }
}

local const omIdle: Csml.StateDescription = new{
  name = "idle"
  on {
    new {
      event = Events.eStartDetectingOccupancy
      target = omMonitoring.name
    }
  }
}

local const omMonitoring: Csml.StateDescription = new {
  name = "monitoring"
  after {
    new Csml.TimeoutActionDescription {
      name = "serviceTimeout"
      delay = "5000"
      action = Actions.aRaiseMaintenance
    }
  }
  on {
    new {
      event = Events.eMaintenanceRequired
      target = omMaintenance.name
    }
    new {
      event = Events.eDetectionComplete
      target = omIdle.name
    }
  }
}

local const omMaintenance: Csml.StateDescription = new {
  name = "maintenance"
  entry {
    new Csml.InvokeActionDescription {
      serviceType = ServiceTypes.stMaintenance
    }
  }
  on{
    new{
      event = Events.eMaintenanceDone
      target = omIdle.name
    }
  }
}

local const tcInit: Csml.StateDescription = new {
  name = "init"
  initial = true
  always {
    new {
      target = tcRun.name
    }
  }
}

local const tcRun: Csml.StateDescription = new {
  name = "run"
  always {
    new {
      target = tcRun1.name
    }
  }
}
local const tcRun1: Csml.StateDescription = new {
  name = "run1"
  always {
    new {
      target = tcRun2.name
    }
  }
}
local const tcRun2: Csml.StateDescription = new {
  name = "run2"
  always {
    new {
      target = tcRun3.name
    }
  }
}
local const tcRun3: Csml.StateDescription = new {
  name = "run3"
  always {
    new {
      target = tcRun4.name
    }
  }
}
local const tcRun4: Csml.StateDescription = new {
  name = "run4"
  always {
    new {
      target = tcRun5.name
    }
  }
}
local const tcRun5: Csml.StateDescription = new {
  name = "run5"
  always {
    new {
      target = tcRun6.name
    }
  }
}
local const tcRun6: Csml.StateDescription = new {
  name = "run6"
  always {
    new {
      target = tcRun7.name
    }
  }
}
local const tcRun7: Csml.StateDescription = new {
  name = "run7"
  always {
    new {
      target = tcRun8.name
    }
  }
}
local const tcRun8: Csml.StateDescription = new {
  name = "run8"
  always {
    new {
      target = tcRun9.name
    }
  }
}
local const tcRun9: Csml.StateDescription = new {
  name = "run9"
  always {
    new {
      target = tcRun10.name
    }
  }
}
local const tcRun10: Csml.StateDescription = new {
  name = "run10"
  always {
    new {
      target = tcRun11.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal1.name
    }
  }
}
local const tcRun11: Csml.StateDescription = new {
  name = "run11"
  always {
    new {
      target = tcRun12.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal2.name
    }
  }
}
local const tcRun12: Csml.StateDescription = new {
  name = "run12"
  always {
    new {
      target = tcRun13.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal3.name
    }
  }
}
local const tcRun13: Csml.StateDescription = new {
  name = "run13"
  always {
    new {
      target = tcRun14.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal4.name
    }
  }
}
local const tcRun14: Csml.StateDescription = new {
  name = "run14"
  always {
    new {
      target = tcRun15.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal6.name
    }
  }
}
local const tcRun15: Csml.StateDescription = new {
  name = "run15"
  always {
    new {
      target = tcRun16.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal7.name
    }
  }
}
local const tcRun16: Csml.StateDescription = new {
  name = "run16"
  always {
    new {
      target = tcFinal.name
    }
  }
  on {
    new {
      event = "final1"
      target = tcFinal7.name
    }
  }
}
local const tcFinal: Csml.StateDescription = new {
  name = "final"
  terminal = true
}
local const tcFinal1: Csml.StateDescription = new {
  name = "final1"
  terminal = true
}
local const tcFinal2: Csml.StateDescription = new {
  name = "final2"
  terminal = true
}
local const tcFinal3: Csml.StateDescription = new {
  name = "final3"
  terminal = true
}
local const tcFinal4: Csml.StateDescription = new {
  name = "final4"
  terminal = true
}
local const tcFinal5: Csml.StateDescription = new {
  name = "final5"
  terminal = true
}
local const tcFinal6: Csml.StateDescription = new {
  name = "final6"
  terminal = true
}
local const tcFinal7: Csml.StateDescription = new {
  name = "final7"
  terminal = true
}